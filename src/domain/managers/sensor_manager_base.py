import random
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from fastapi import Depends
from sqlalchemy.orm import Session
from time import sleep, time
from typing import List, Sequence, Optional
from src.domain.models.record_session import RecordSession
from src.domain.repositories.record_repository import RecordRepository
from src.domain.repositories.record_session_repository import RecordSessionRepository
from src.infrastructure.services.database import get_db
from models.recorded_datum import RecordedData


class EcgSensorManagerBase:
    """The base class of ECG sensor service.

    This is the base class of ECG sensor service which has all the main
    functionality that is shared between the local development mock service
    with the actual service. Due to multiple packages that can't be built
    when ran on development computer, through dynamic importing, we're 
    bypassing that with mock service to fully test the functionality.

    Attributes:
        is_diagnosis_set(bool): A boolean that indicated whether the diagnosis_id was set
        diagnosis_id(bool): The Diagnosis Id that was created in Piezo sensor service.
        session(Session): The session that was created when running the scheduler.
    """
    __session: Optional[RecordSession]
    __instance = None

    @property
    def instance(self, db: Session = Depends(get_db)):
        """Get the current instance of EcgSensorService

        Retrieve or create a new instance of EcgSensorServiceBase for singleton
        implementation.

        Returns:
            The instance of EcgSensorServiceBase and maintain singleton design.
        """
        
        if not EcgSensorManagerBase.__instance:
            EcgSensorManagerBase.__instance = EcgSensorManagerBase(db)
        return EcgSensorManagerBase.__instance

    def __init__(self, db: Session = Depends(get_db)):
        self.__data: List[RecordedData] = []
        self.__secondary_data: List[RecordedData] = []
        self.__db = db
        self.__record_repository = RecordRepository()
        self.__record_session_repository = RecordSessionRepository(self.__db)
        self.scheduler = AsyncIOScheduler()
        self.scheduler.add_job(
            self.__reading_ecg_sensor_data, "interval", seconds=0.1, jitter=True
        )

    def get_data(self):
        """Get the current data in buffer

        Retrieve the current amount of data in the buffer to send back
        to front end for real-time display. If current buffer doesn't have
        enough data points, this will check and append the secondary store
        to make up for it.

        Returns:
            A list of data that will be sent to the front end for display 
            with the following format:
            [
                {
                    timestamp: UTC timestamp string,
                    data: sensor data float
                }
            ]
        """

        if len(self.__data) < 20:
            return (self.__data + self.__secondary_data)[-20:]
        return list(self.__data)

    def start_reading_values(self):
        """Start reading sensor values cycle.

        Create a new session and start up the scheduler to read sensor values
        in interval.
        """

        self.session = self.__record_session_repository.create()
        self.scheduler.start()

    def stop_reading_values(self):
        """Stop the reading sensor values cycle.

        Pause the scheduler so that we can start later on.
        Save the recorded data into the database.
        Reset the current read buffer.
        """

        self.scheduler.pause()

        print(f"Thread status: [{self.scheduler.running}]")

        self.__record_repository.create(self.__data, self.__get_session_id())
        self.__data = []
        self.__secondary_data = []

    def get_sensor_values(self):
        """Get the mock sensor value.

        Retrieve the mock sensor value generated by random.
        This function will be override to get sensor value through GPIO
        when run on Raspberry PI environment.

        Returns:
            A randome float value for testing purposes.
        """

        return random.random()

    def __reading_ecg_sensor_data(self):
        if self.is_diagnosis_set and self.session is not None:
            self.is_diagnosis_set = False
            self.__session.DiagnosisId = self.diagnosis_id  # type: ignore
            self.__record_session_repository.save(self.session)
            self.diagnosis_id = 0

        if len(self.__data) >= 1000:
            temp = self.__data
            self.__data = self.__secondary_data
            self.__secondary_data = temp
            self.__record_repository.create(
                self.__secondary_data, self.__get_session_id()
            )

        current_timestamp = round(time() * 1000)
        list(self.__data).append(
            RecordedData(
                timeStamp=current_timestamp,
                data=self.get_sensor_values(),
            )
        )
        sleep(0.01)

    def __get_session_id(self):
        session_id = 0
        if self.session is not None:
            session_id = self.session.Id
        return session_id
